# -*- coding: utf-8 -*-
"""Spectral_analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Iv0EDBdszYY4noUegAyF23EHbCBAAM6H

# Spectral Analysis & Turbulence

Trying to understand how energy cascades work in turbulent flows. Read about Kolmogorov's -5/3 law in Pope's textbook and want to verify it computationally.

**Goal:** Generate synthetic turbulence signal and analyze its power spectrum to see if it matches Kolmogorov theory.

## Background (Physics)
In turbulent flows:
- Large eddies break down into smaller eddies (energy cascade)
- Energy spectrum follows E(k) ∝ k^(-5/3) (Kolmogorov 1941)
- This is one of the few universal laws in turbulence!

References: Pope Chapter 6, Tennekes & Lumley
"""

# Spectral analysis - turbulence stuff
# Trying to understand energy cascades in turbulent flows
import numpy as np
import matplotlib.pyplot as plt
from scipy.fft import fft, fftfreq

# might need more imports later

# Generate synthetic turbulence data
# Based on Kolmogorov spectrum: E(k) ~ k^(-5/3)

duration = 100  # seconds
dt = 0.01  # sampling rate
t = np.arange(0, duration, dt)
N = len(t)

# Build signal in frequency space with -5/3 spectrum
signal = np.zeros(N)
freqs = fftfreq(N, dt)

# Add modes with Kolmogorov amplitudes
num_modes = 1000
for i in range(1, min(num_modes, N//2)):
    if freqs[i] == 0:
        continue
    amp = np.abs(freqs[i])**(-5/6)  # -5/3 in power -> -5/6 in amplitude
    phase = 2*np.pi*np.random.random()
    signal += amp * np.sin(2*np.pi*freqs[i]*t + phase)

# Add small-scale noise
signal += 0.1*np.random.randn(N)

# Quick check
plt.figure(figsize=(12, 4))
plt.plot(t[:1000], signal[:1000])
plt.xlabel('Time (s)'); plt.ylabel('u (m/s)')
plt.title('Synthetic turbulent velocity')
plt.grid(alpha=0.3)
plt.show()

print(f"Generated {N} points, looks turbulent!")

# FFT to get power spectrum
# Need to remove mean first (otherwise huge DC spike)

u_fluct = signal - np.mean(signal)

# Do FFT
fft_vals = fft(u_fluct)
freqs = fftfreq(len(u_fluct), dt)

# Power spectrum = |FFT|^2
power = np.abs(fft_vals)**2

# Only keep positive frequencies (negative are redundant for real signals)
pos_idx = freqs > 0
f_pos = freqs[pos_idx]
P_pos = power[pos_idx]

# Plot
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))

ax1.plot(t[:2000], u_fluct[:2000], 'b', linewidth=0.8)
ax1.set_xlabel('Time (s)'); ax1.set_ylabel('u\' (m/s)')
ax1.set_title('Velocity fluctuations (first 20s)')
ax1.grid(alpha=0.3)

ax2.loglog(f_pos, P_pos, 'r', linewidth=0.8)
ax2.set_xlabel('Frequency (Hz)'); ax2.set_ylabel('Power')
ax2.set_title('Power spectrum')
ax2.grid(alpha=0.3)

plt.tight_layout()
plt.show()

# Broad spectrum = turbulence (chaotic behavior across scales)

# Check if spectrum follows Kolmogorov's -5/3 law
# Convert frequency to wavenumber using Taylor's hypothesis: k = 2πf/U

U = 1.0  # assume mean velocity 1 m/s (arbitrary for synthetic data)
k = 2*np.pi*f_pos / U

# Theoretical Kolmogorov: E(k) ~ k^(-5/3)
k_theory = np.logspace(np.log10(k[1]), np.log10(k[-1]), 100)
E_theory = k_theory**(-5/3)

# Scale theory to match data (just for comparison, absolute values don't matter)
scale = np.mean(P_pos[10:100]) / np.mean(E_theory[10:100])
E_theory *= scale

# Plot
plt.figure(figsize=(10, 6))
plt.loglog(k, P_pos, 'b', alpha=0.7, linewidth=1, label='Simulation')
plt.loglog(k_theory, E_theory, 'r--', linewidth=2, label='Kolmogorov -5/3')

# Add reference slopes
k_ref = np.array([0.1, 1])
P_ref_53 = k_ref**(-5/3) * (P_pos[10] / k[10]**(-5/3))
plt.loglog(k_ref, P_ref_53, 'g--', label='-5/3 slope', linewidth=2)

plt.xlabel('Wavenumber k (rad/m)')
plt.ylabel('Energy E(k)')
plt.title('Verifying Kolmogorov -5/3 Law')
plt.legend()
plt.grid(alpha=0.3)
plt.show()

# Pretty good match in the inertial range!
# At low k (large scales): energy injection
# At high k (small scales): dissipation

# Visualize energy cascade concept
# Large eddies → medium eddies → small eddies → dissipation

eddy_sizes = np.logspace(0, -3, 50)  # 1m to 1mm
energy_rate = eddy_sizes**(2/3)  # dimensional argument

fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 6))

# Cartoon of cascade
y = 1.0
for i, L in enumerate(eddy_sizes[::5]):  # every 5th eddy
    ax1.add_patch(plt.Circle((i*0.5, y), L*2, alpha=0.6, color='blue'))
    if i < len(eddy_sizes[::5])-1:
        ax1.arrow(i*0.5, y-0.2, 0.4, 0, head_width=0.05, head_length=0.1, fc='red')

ax1.set_xlim(-0.5, 5); ax1.set_ylim(0.5, 1.5)
ax1.set_xlabel('Step'); ax1.set_title('Energy Cascade Process')
ax1.set_aspect('equal')

# Energy transfer rate (constant in inertial range)
ax2.loglog(eddy_sizes, energy_rate, 'ro-', linewidth=2)
ax2.set_xlabel('Eddy size L (m)'); ax2.set_ylabel('ε (energy flux)')
ax2.set_title('Energy Transfer Across Scales')
ax2.grid(alpha=0.3)
ax2.invert_xaxis()

plt.tight_layout()
plt.show()

# This is Richardson's cascade: "Big whorls have little whorls..."

# Extra: FFT filtering demo
# Low-pass filter to remove high-frequency noise

from scipy.fft import ifft

# Create test signal with multiple frequencies
t_test = np.linspace(0, 10, 1000)
clean = (np.sin(2*np.pi*5*t_test) +           # 5 Hz
         0.5*np.sin(2*np.pi*50*t_test) +      # 50 Hz
         0.1*np.sin(2*np.pi*200*t_test))      # 200 Hz (will be filtered out)
noisy = clean + 0.2*np.random.randn(len(t_test))

# FFT of both
fft_clean = fft(clean - np.mean(clean))
fft_noisy = fft(noisy - np.mean(noisy))
freq_test = fftfreq(len(t_test), t_test[1]-t_test[0])

# Low-pass filter: kill everything above 100 Hz
cutoff = 100
mask = np.abs(freq_test) < cutoff
fft_filt = fft_noisy * mask
filtered = np.real(ifft(fft_filt))

# Plot 2x2 grid
fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# Top left: Time domain comparison (clean vs noisy)
axes[0,0].plot(t_test, clean, 'b', alpha=0.7, label='Clean')
axes[0,0].plot(t_test, noisy, 'r', alpha=0.5, label='Noisy')
axes[0,0].set_xlabel('Time'); axes[0,0].set_ylabel('Signal')
axes[0,0].set_title('Time Domain: Clean vs Noisy')
axes[0,0].legend(); axes[0,0].grid(alpha=0.3)

# Top right: Frequency domain comparison
pos = freq_test > 0
axes[0,1].loglog(freq_test[pos], np.abs(fft_clean[pos])**2, 'b', alpha=0.7, label='Clean')
axes[0,1].loglog(freq_test[pos], np.abs(fft_noisy[pos])**2, 'r', alpha=0.5, label='Noisy')
axes[0,1].set_xlabel('Freq (Hz)'); axes[0,1].set_ylabel('Power')
axes[0,1].set_title('Frequency Domain')
axes[0,1].legend(); axes[0,1].grid(alpha=0.3)

# Bottom left: Filtered time domain
axes[1,0].plot(t_test, noisy, 'r', alpha=0.3, label='Noisy')
axes[1,0].plot(t_test, filtered, 'g', linewidth=2, label='Filtered')
axes[1,0].set_xlabel('Time'); axes[1,0].set_ylabel('Signal')
axes[1,0].set_title('After Low-Pass Filtering')
axes[1,0].legend(); axes[1,0].grid(alpha=0.3)

# Bottom right: Filtered frequency domain
axes[1,1].loglog(freq_test[pos], np.abs(fft_noisy[pos])**2, 'r', alpha=0.3, label='Noisy')
axes[1,1].loglog(freq_test[pos], np.abs(fft_filt[pos])**2, 'g', linewidth=2, label='Filtered')
axes[1,1].axvline(cutoff, color='k', linestyle='--', label='Cutoff')
axes[1,1].set_xlabel('Freq (Hz)'); axes[1,1].set_ylabel('Power')
axes[1,1].set_title('Filtered Spectrum')
axes[1,1].legend(); axes[1,1].grid(alpha=0.3)

plt.tight_layout()
plt.show()

# Filter removes high-freq noise (>100Hz) while keeping main signals (5Hz, 50Hz)

"""## Summary

Successfully verified Kolmogorov's -5/3 law using synthetic turbulence:
- Generated signal with prescribed power-law spectrum
- FFT analysis confirms E(k) ∝ k^(-5/3) in inertial range
- Energy cascade visualization shows scale-by-scale transfer

**Next steps:**
- Apply to real PIV data from wind tunnel experiments
- Calculate turbulent dissipation rate ε
- Look at structure functions (maybe better than spectra for intermittency)

**Issues encountered:**
- Had to remove DC component before FFT (huge spike at f=0)
- Scaling between frequency and wavenumber needs Taylor's frozen turbulence hypothesis
- At high frequencies, spectrum deviates due to numerical noise (expected)
"""

